var documenterSearchIndex = {"docs":
[{"location":"storage/#Storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"The storage module tries to stay as generic as possible, making no assumption about the transformation used or the configuration (e.g., the fingerprint). This is also where the functionalities exposed by the library are living.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"CurrentModule = GD.Storage","category":"page"},{"location":"storage/#Compressor","page":"Storage","title":"Compressor","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"Abstraction used by the used by the store to be able to work independently of the underlying configuration and the transformation. This module is stateless, as it exposes functions which are purely functional. Thus, one store can scale the compressor module easily.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Compressor\ncompress\nextract(::Compressor, ::GDFile, ::Vector{Vector{UInt8}})\nhashes","category":"page"},{"location":"storage/#GD.Storage.Compressor","page":"Storage","title":"GD.Storage.Compressor","text":"Compressor(chunksize, transformer, fingerprint)\n\nCompresses/Extracts data according to the loaded configuration. A Compressor  is stateless. It is focused on data compression/extraction but does not store  any value for deduplication.\n\nfingerprint is a hashing function with the following signature:\n\nfingerprint(data::Vector{Vector{UInt8}})::Vector{Vector{UInt8}}\n\nClassic examples of fingerprints functions are CRC32 and SHA from the standard library.\n\n\n\n\n\n","category":"type"},{"location":"storage/#GD.Storage.compress","page":"Storage","title":"GD.Storage.compress","text":"compress(compressor, data)\n\nReturns a compressed version of data, as well as the bases which need to be used by compressor for reconstructing data. \n\n\n\n\n\n","category":"function"},{"location":"storage/#GD.Storage.extract-Tuple{GD.Storage.Compressor,GD.Storage.GDFile,Array{Array{UInt8,1},1}}","page":"Storage","title":"GD.Storage.extract","text":"extract(compressor, gdfile, bases)\n\nDecompresses gdfile into its original representation.\n\n\n\n\n\n","category":"method"},{"location":"storage/#GD.Storage.hashes","page":"Storage","title":"GD.Storage.hashes","text":"hashes(compressor, data)\n\nHashes each element in data with the compressor.fingerprint and return an array of hashes.\n\n\n\n\n\n","category":"function"},{"location":"storage/#GDFile","page":"Storage","title":"GDFile","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"Data structure outputted by the compression process. This structure contains the hashes generated by the fingerprint and the deviations. padsize indicates if the last chunk used for generating the file has been zero-padded. This occurs when the number of chunks given to the compressor is not a multiple of the configured chunksize.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"GDFile","category":"page"},{"location":"storage/#GD.Storage.GDFile","page":"Storage","title":"GD.Storage.GDFile","text":"GDFile(hashes, deviations, padsize)\n\nData structure holding the compressed representation of data generated by a compressor. Suitable for storing (through serialization) or exchanging over  the network.\n\n\n\n\n\n","category":"type"},{"location":"storage/#Patching","page":"Storage","title":"Patching","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"This data structure can be patched by applying a simple delta compression algorithm through the functions patch and unpatch. The functionality can be leveraged when distributed stores are working together, as long as all the stores communicating posses the original file (gdfile2) to either patch or unpatch the modified version (gdfile1).","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"patch\nunpatch","category":"page"},{"location":"storage/#GD.Storage.patch","page":"Storage","title":"GD.Storage.patch","text":"patch(gdfile1, gdfile2)\n\nPatches gdfile1 by replacing the hashes/deviations which are the same as gdfile2 by [0x00].\n\n\n\n\n\n","category":"function"},{"location":"storage/#GD.Storage.unpatch","page":"Storage","title":"GD.Storage.unpatch","text":"unpatch(gdfile1, gdfile2)\n\nUnpachtes gdfile1 by repalcing [0x00] from gdfile1 by the value contianed in gdfile2.\n\n\n\n\n\n","category":"function"},{"location":"storage/#Store","page":"Storage","title":"Store","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"The store glues the other module together and offer an easy-to-use API for  the (de)compression of chunks.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Store\ncompress!\nextract(::Store, ::GDFile)\nget\nupdate!\nvalidate","category":"page"},{"location":"storage/#GD.Storage.Store","page":"Storage","title":"GD.Storage.Store","text":"Store(compressor, database)\n\nUnifies the Compressor module and the database. The Store handles the deduplication process by storing the bases generated by the Compressor into the database.\n\n\n\n\n\n","category":"type"},{"location":"storage/#GD.Storage.compress!","page":"Storage","title":"GD.Storage.compress!","text":"compress!(store, data)\n\nStores the bases generated from data into the database and returns a compressed version of data as a GDFile.\n\n\n\n\n\n","category":"function"},{"location":"storage/#GD.Storage.extract-Tuple{GD.Storage.Store,GD.Storage.GDFile}","page":"Storage","title":"GD.Storage.extract","text":"extract(store, gdfile)\n\nDecompresses the gdfile into its original representation. This methods assumes that a valide GDFile is given as input (the validate() method must return  []).\n\n\n\n\n\n","category":"method"},{"location":"storage/#GD.Storage.get","page":"Storage","title":"GD.Storage.get","text":"get(store, hashes)\n\nreturns the values mapped to hashes in store.\n\n\n\n\n\n","category":"function"},{"location":"storage/#GD.Storage.update!","page":"Storage","title":"GD.Storage.update!","text":"update!(store, hashes}, bases)\n\nUpdates store.database by mapping hashes to bases.\n\n\n\n\n\n","category":"function"},{"location":"storage/#GD.Storage.validate","page":"Storage","title":"GD.Storage.validate","text":"validate(store, gdfile)\n\nChecks wether gdfile can be extracted by store or not by returning the list  of unknown hashes used by gdfile. The GDFile is said valid if validate() returns [].\n\n\n\n\n\n","category":"function"},{"location":"transform/#Transform","page":"Transform","title":"Transform","text":"","category":"section"},{"location":"transform/","page":"Transform","title":"Transform","text":"The transform module exposes a well-defined interface which need to be implemented by any Transformer, i.e., the function producing the base and deviation used by the GD Store.","category":"page"},{"location":"transform/","page":"Transform","title":"Transform","text":"CurrentModule = GD.Transform","category":"page"},{"location":"transform/#AbstractTransformer","page":"Transform","title":"AbstractTransformer","text":"","category":"section"},{"location":"transform/","page":"Transform","title":"Transform","text":"This is the abstract type that a new transformer need to implement in order to be usable by the store. The functions transform and invtransform need to  respect the given signatures.","category":"page"},{"location":"transform/","page":"Transform","title":"Transform","text":"AbstractTransformer\ntransform(::AbstractTransformer, ::Vector{T}) where T <: Unsigned\ninvtransform(::AbstractTransformer, ::Vector{UInt8}, ::Vector{UInt8})","category":"page"},{"location":"transform/#GD.Transform.AbstractTransformer","page":"Transform","title":"GD.Transform.AbstractTransformer","text":"AbstractTransformer\n\nInterface to implement for creating a new transformer.\n\n\n\n\n\n","category":"type"},{"location":"transform/#GD.Transform.transform-Union{Tuple{T}, Tuple{GD.Transform.AbstractTransformer,Array{T,1}}} where T<:Unsigned","page":"Transform","title":"GD.Transform.transform","text":"transform(transformer, data)\n\nApplies the transformer transformation to data and returns a split  representation under the form (basis, deviation).\n\n\n\n\n\n","category":"method"},{"location":"transform/#GD.Transform.invtransform-Tuple{GD.Transform.AbstractTransformer,Array{UInt8,1},Array{UInt8,1}}","page":"Transform","title":"GD.Transform.invtransform","text":"invtransform(transformer, basis, deviation)\n\nReverses the transformation applied by transformer and returns the original data.\n\n\n\n\n\n","category":"method"},{"location":"transform/#GD-Quantization","page":"Transform","title":"GD Quantization","text":"","category":"section"},{"location":"transform/","page":"Transform","title":"Transform","text":"GD Quantization is applying a lossless quantization which store the quantization error in the deviation.","category":"page"},{"location":"transform/","page":"Transform","title":"Transform","text":"Quantizer\ntransform(::Quantizer{T}, ::Vector{T}) where T <: Unsigned\ninvtransform(::Quantizer{T}, ::Vector{UInt8}, ::Vector{UInt8}) where T <: Unsigned","category":"page"},{"location":"transform/#GD.Transform.Quantizer","page":"Transform","title":"GD.Transform.Quantizer","text":"Quantizer\n\nTransformer which creates a basis and deviation pair as follow:\n\nbasis: keeps only the msbsize MSB of each byte\ndeviation: keeps the remaing lsbsize LSB of each byte\n\n\n\n\n\n","category":"type"},{"location":"transform/#GD.Transform.transform-Union{Tuple{T}, Tuple{GD.Transform.Quantizer{T},Array{T,1}}} where T<:Unsigned","page":"Transform","title":"GD.Transform.transform","text":"transform(quantizer, data)\n\nCuts each element from data into a basis containing the quantizer.msbsize MSB  of the element, and a deviation containing the quantizer.lsbsize LSB of the element.\n\nReturns the concatenation of the MSB of the bytes as the basis, and the  concatenation of the LSB of the bytes as the deviation.\n\n\n\n\n\n","category":"method"},{"location":"transform/#GD.Transform.invtransform-Union{Tuple{T}, Tuple{GD.Transform.Quantizer{T},Array{UInt8,1},Array{UInt8,1}}} where T<:Unsigned","page":"Transform","title":"GD.Transform.invtransform","text":"invtransform(quantizer, basis, deviation)\n\nExtracts each couple (MSB, LSB) from basis and deviation and rebuilds the  original data by combining them.\n\nReturns the original byte array which has been transformed by transform().\n\n\n\n\n\n","category":"method"},{"location":"#GD.jl","page":"Home","title":"GD.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GD.jl is an in-memory Generalized Deduplication (GD) data store which can be used for compressing the network traffic of a distributed infrastructure. The design of the library tries to follow these guidelines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Configurable: GD configuration can vary a lot depending on the data we are compressing. Adjusting the chunk size, the fingerprint, or picking a suitable transformation is the responsibility of the user, as the store does not assume these values.\nExtensible: The platform has been built with research in mind and writing custom compression transformations do not depend on the rest of the library. Thus, implementing experimental transformations is easy to do. In the same way, an extension of the library implements the inter-store communication which exposes a micro HTTP API. This part can be ditched, extended, or rewritten completely with another communication protocol without impacting the rest of the architecture.\nGeneric: GD.jl is composed of multiple blocks mainly working at an abstract level. Thus, the store exposes the necessary primitives required to use it, while staying “transformation-agnostic”.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Setting up a local store can be done in three simple steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GD: Storage, Transform\nusing SHA: sha1\n\n\n# 1. Pick a transformation to compress data.\nmsbsize = 0x06\nchunksize = 256\ntransformer = Transform.Quantizer{UInt8}(chunksize, msbsize)\n\n# 2. Configure the compressor.\nfingerprint = sha1\ncompressor = Storage.Compressor(chunksize, transformer, fingerprint)\n\n# 3. Instanciate the in-memory data store.\ndatabase = Dict()\nstore = Storage.Store(compressor, database)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the setup in place, using the API to compress and extract data is pretty straightforward:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# fake data\ndata = rand(UInt8, 1000)\n\n# Compress data.\ngdfile = Storage.compress!(store, data)\n\n# Check file validity.\n@assert Storage.validate(store, gdfile) == UInt8[]\n\n# Extract gdfile.\n@assert Storage.extract(store, gdfile) == data","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is no need to check the file validity as long as only one local store is used. However, this function is coming handy when decompressing GDFile coming from a remote location, as the local store may lack certain bases required for the decompression.","category":"page"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Internally, the store is composed of five modules working together:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compressor: Holds the configuration of the transformation and pretty much any other variables configured by the user related to the compression process. This module is stateless and can (de)compress without being tied to a specific transformer.\nDatabase: Key-value data store (really nothing more than a simple Dict) holding the couples (hash, deviation).\nGDFile: Data structure used by the compressed data.\nTransform: Abstraction of the transformer. This module defines the interface to implement for the creation of a new transformer. This is also the home of all the implemented transformer.\nStore: Acts as an orchestrator that glues the other components together and exposes an easy-to-use API for the user.","category":"page"},{"location":"#Working-with-distributed-stores-for-network-compression","page":"Home","title":"Working with distributed stores for network compression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GD.jl provides a tiny HTTP API which can be setup for inter-store communication. This extension is experimental, very basic and certainly not targeting high-performance communication. Use at your own risk.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Okay, okay, give me the goods now!","category":"page"},{"location":"","page":"Home","title":"Home","text":"host = \"127.0.0.1\"\nport = \"9090\"\n@async Storage.setup_api_endpoint(store, host, port)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where http://host:port is the baseurl used to contact the store endpoint. Decompressing a file coming from a remote location becomes a two-step process:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# 1. Validate the `GDFile` coming from a remote location and requesting the\n#    missing bases for our local store. \nStorage.validate_remote!(store, data, \"http://127.0.0.1:9090\")\n\n# 2. Extract as usual now that our file is valid.\ndata = Storage.extract(store, data)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis functionality has a serious limitation: validating a GDFile by requesting bases from a store which do not possess them will generate an unhandled error.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generalized deduplication literature:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generalized Deduplication: Lossless Compression for Large Amounts of Small IoT Data\nLossless Compression of Time Series Data with Generalized Deduplication\nA Randomly Accessible Lossless Compression Scheme for Time-Series Data\nHermes: Enabling Energy-efficient IoT Networks with Generalized Deduplication","category":"page"}]
}
